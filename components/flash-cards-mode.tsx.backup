"use client"

import type React from "react"

import { useState, useEffect } from "react"
import { Card } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { motion } from "framer-motion"
import { Clock, Calendar, CalendarDays, Star, Edit, Trash2, Info, History as HistoryIcon } from "lucide-react"
import { useWordBank, type Word } from "@/contexts/word-bank-context"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import { FSRS, Rating } from "fsrs.js"

// Update the component signature to accept props
export default function FlashCardsMode({
  state = { activeTab: "today" },
  setState = () => {},
}: {
  state?: { activeTab: string }
  setState?: (state: { activeTab: string }) => void
} = {}) {
  // Replace the activeTab state with a derived state from props
  const [activeTab, setActiveTab] = useState(state.activeTab)

  // Update the tab change handler
  const handleTabChange = (value: string) => {
    setActiveTab(value)
    setState({ activeTab: value })
  }

  const [currentCardIndex, setCurrentCardIndex] = useState(0)
  const [isFlipped, setIsFlipped] = useState(false)
  const [reviewGroups, setReviewGroups] = useState<{ today: Word[]; tomorrow: Word[]; later: Word[] }>({
    today: [],
    tomorrow: [],
    later: [],
  })
  const { scheduleReview, getWordsForReview, updateWord, deleteWord } = useWordBank()
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false)
  const [editingWord, setEditingWord] = useState<Word | null>(null)
  const [editedMeaning, setEditedMeaning] = useState("")
  const [editedExampleSentence, setEditedExampleSentence] = useState("")
  const [editedExampleSentenceTranslation, setEditedExampleSentenceTranslation] = useState("")
  const [confirmDeleteId, setConfirmDeleteId] = useState<number | null>(null)
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false)
  const [isHistoryDialogOpen, setIsHistoryDialogOpen] = useState(false)
  const [historyWord, setHistoryWord] = useState<Word | null>(null)

  useEffect(() => {
    // Get words for review
    const groups = getWordsForReview()
    setReviewGroups(groups)
    setCurrentCardIndex(0)
    setIsFlipped(false)
  }, [getWordsForReview])
  
  // Add an effect to ensure currentCardIndex is valid
  useEffect(() => {
    // Reset currentCardIndex if it's out of bounds
    if (reviewGroups.today.length === 0) {
      setCurrentCardIndex(0);
    } else if (currentCardIndex >= reviewGroups.today.length) {
      setCurrentCardIndex(reviewGroups.today.length - 1);
    }
  }, [reviewGroups.today, currentCardIndex]);

  const handleFlip = () => {
    // Only flip if there are cards to review
    if (reviewGroups.today.length === 0 || !reviewGroups.today[currentCardIndex]) return;
    setIsFlipped(!isFlipped);
  }

  const handleAgain = () => {
    // Safety check to ensure there are cards to review
    if (reviewGroups.today.length === 0 || !reviewGroups.today[currentCardIndex]) return;

    const currentWord = reviewGroups.today[currentCardIndex];

    // Schedule for review with quality 1 (Again)
    scheduleReview(currentWord.id, 1);

    // Remove the current card from today's stack temporarily
    const updatedToday = [...reviewGroups.today];
    updatedToday.splice(currentCardIndex, 1);

    setReviewGroups({
      ...reviewGroups,
      today: updatedToday,
    });

    // Check if this was the last card
    if (updatedToday.length > 0) {
      setIsFlipped(false);
      setTimeout(() => {
        setCurrentCardIndex(currentCardIndex >= updatedToday.length ? 0 : currentCardIndex);
      }, 300);
    } else {
      // No more cards for now
      setCurrentCardIndex(0);
      setIsFlipped(false);
    }

    // Set up a timer to refresh the review groups after a minute
    // This will bring back the card that was just marked as "Again"
    setTimeout(() => {
      const updatedGroups = getWordsForReview();
      setReviewGroups(updatedGroups);
    }, 65 * 1000); // 65 seconds to ensure the 1-minute delay has passed
  };

  const handleHard = () => {
    // Safety check to ensure there are cards to review
    if (reviewGroups.today.length === 0 || !reviewGroups.today[currentCardIndex]) return;

    const currentWord = reviewGroups.today[currentCardIndex];

    // Schedule for review with quality 2 (Hard)
    scheduleReview(currentWord.id, 2);

    // Remove the card from today's stack
    const updatedToday = [...reviewGroups.today];
    updatedToday.splice(currentCardIndex, 1);

    setReviewGroups({
      ...reviewGroups,
      today: updatedToday,
    });

    // Move to next card or reset if this was the last card
    if (updatedToday.length > 0) {
      setIsFlipped(false);
      setTimeout(() => {
        setCurrentCardIndex(currentCardIndex >= updatedToday.length ? 0 : currentCardIndex);
      }, 300);
    } else {
      // No more cards for today
      setCurrentCardIndex(0);
      setIsFlipped(false);
    }
  };

  const handleGood = () => {
    // Safety check to ensure there are cards to review
    if (reviewGroups.today.length === 0 || !reviewGroups.today[currentCardIndex]) return;

    const currentWord = reviewGroups.today[currentCardIndex];

    // Schedule for review with quality 3 (Good)
    scheduleReview(currentWord.id, 3);

    // Remove from today's stack
    const updatedToday = [...reviewGroups.today];
    updatedToday.splice(currentCardIndex, 1);

    setReviewGroups({
      ...reviewGroups,
      today: updatedToday,
    });

    // Move to next card or reset if this was the last card
    if (updatedToday.length > 0) {
      setIsFlipped(false);
      setTimeout(() => {
        setCurrentCardIndex(currentCardIndex >= updatedToday.length ? 0 : currentCardIndex);
      }, 300);
    } else {
      // No more cards for today
      setCurrentCardIndex(0);
      setIsFlipped(false);
    }
  };

  const handleEasy = () => {
    // Safety check to ensure there are cards to review
    if (reviewGroups.today.length === 0 || !reviewGroups.today[currentCardIndex]) return;

    const currentWord = reviewGroups.today[currentCardIndex];

    // Schedule for review with quality 4 (Easy)
    scheduleReview(currentWord.id, 4);

    // Remove from today's stack
    const updatedToday = [...reviewGroups.today];
    updatedToday.splice(currentCardIndex, 1);

    setReviewGroups({
      ...reviewGroups,
      today: updatedToday,
    });

    // Move to next card or reset if this was the last card
    if (updatedToday.length > 0) {
      setIsFlipped(false);
      setTimeout(() => {
        setCurrentCardIndex(currentCardIndex >= updatedToday.length ? 0 : currentCardIndex);
      }, 300);
    } else {
      // No more cards for today
      setCurrentCardIndex(0);
      setIsFlipped(false);
    }
  };

  const getConfidenceColor = (confidence: number, learned: boolean) => {
    if (learned) return "text-green-600"

    switch (confidence) {
      case 1:
        return "text-red-500"
      case 2:
        return "text-orange-500"
      case 3:
        return "text-amber-500"
      case 4:
        return "text-blue-500"
      case 5:
        return "text-green-500"
      default:
        return "text-gray-500"
    }
  }

  const getConfidenceBadgeClass = (confidence: number, learned: boolean) => {
    const baseClass = "flex items-center gap-1 px-2 py-1 rounded-full font-bold text-white"

    if (learned) return `${baseClass} bg-green-600`

    switch (confidence) {
      case 1:
        return `${baseClass} bg-red-500`
      case 2:
        return `${baseClass} bg-orange-500`
      case 3:
        return `${baseClass} bg-amber-500`
      case 4:
        return `${baseClass} bg-blue-500`
      case 5:
        return `${baseClass} bg-green-500`
      default:
        return `${baseClass} bg-gray-500`
    }
  }

  const handleEditClick = (word: Word, e?: React.MouseEvent) => {
    if (e) e.stopPropagation() // Prevent card flip if event is provided
    setEditingWord(word)
    setEditedMeaning(word.meaning)
    setEditedExampleSentence(word.exampleSentence || "")
    setEditedExampleSentenceTranslation(word.exampleSentenceTranslation || "")
    setIsEditDialogOpen(true)
  }

  const handleHistoryClick = (word: Word, e?: React.MouseEvent) => {
    if (e) e.stopPropagation() // Prevent card flip if event is provided
    setHistoryWord(word)
    setIsHistoryDialogOpen(true)
  }

  // Format the next review date in a user-friendly way
  const formatNextReview = (dateString?: string) => {
    if (!dateString) return "Not scheduled";
    
    const reviewDate = new Date(dateString);
    const now = new Date();
    const diffTime = reviewDate.getTime() - now.getTime();
    const diffMinutes = Math.ceil(diffTime / (1000 * 60));
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffMinutes <= 0) return "Now";
    if (diffMinutes < 60) return `${diffMinutes} minutes`;
    if (diffMinutes < 120) return `1 hour`;
    if (diffMinutes < 24 * 60) return `${Math.floor(diffMinutes / 60)} hours`;
    if (diffDays === 1) return "Tomorrow";
    if (diffDays < 7) return `${diffDays} days`;
    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks`;
    return `${Math.floor(diffDays / 30)} months`;
  }
  
  // Display interval information in a user-friendly way
  const formatInterval = (interval?: number): string => {
    if (!interval) return "New";
    
    // For minutes (interval is actual minutes when less than 1 day)
    if (interval < 60) return `${interval} min`;
    if (interval < 120) return `1 hour`;
    if (interval < 24 * 60) return `${Math.floor(interval / 60)} hours`;
    
    // For days and longer (interval is days when 1 day or more)
    if (interval === 1) return "1 day";
    if (interval < 7) return `${interval} days`;
    if (interval < 30) return `${Math.floor(interval / 7)} weeks`;
    if (interval < 365) return `${Math.floor(interval / 30)} months`;
    return `${Math.floor(interval / 365)} years`;
  }

  // Format stability value for display
  const formatStability = (stability?: number) => {
    if (stability === undefined || stability === null) return "New";
    
    // Round to 1 decimal place for display
    const stabilityValue = Math.round(stability * 10) / 10;
    
    if (stabilityValue < 1) return `${stabilityValue.toFixed(1)} (Very low)`;
    if (stabilityValue < 5) return `${stabilityValue.toFixed(1)} (Low)`;
    if (stabilityValue < 15) return `${stabilityValue.toFixed(1)} (Medium)`;
    if (stabilityValue < 30) return `${stabilityValue.toFixed(1)} (High)`;
    return `${stabilityValue.toFixed(1)} (Very high)`;
  }

  // Format difficulty value for display
  const formatDifficulty = (difficulty?: number) => {
    if (difficulty === undefined || difficulty === null) return "Medium";
    
    // Convert to percentage
    const pct = Math.round(difficulty * 100);
    
    if (pct < 20) return `${pct}% (Very easy)`;
    if (pct < 40) return `${pct}% (Easy)`;
    if (pct < 60) return `${pct}% (Medium)`;
    if (pct < 80) return `${pct}% (Hard)`;
    return `${pct}% (Very hard)`;
  }

  const handleSaveEdit = () => {
    if (editingWord) {
      updateWord(editingWord.id, {
        meaning: editedMeaning,
        exampleSentence: editedExampleSentence,
        exampleSentenceTranslation: editedExampleSentenceTranslation,
      })

      // Update the current card if it's the one being edited
      if (reviewGroups.today.length > 0 && reviewGroups.today[currentCardIndex].id === editingWord.id) {
        const updatedToday = [...reviewGroups.today]
        updatedToday[currentCardIndex] = {
          ...updatedToday[currentCardIndex],
          meaning: editedMeaning,
          exampleSentence: editedExampleSentence,
          exampleSentenceTranslation: editedExampleSentenceTranslation,
        }
        setReviewGroups({
          ...reviewGroups,
          today: updatedToday,
        })
      }

      setIsEditDialogOpen(false)
      setEditingWord(null)
    }
  }

  const handleDeleteClick = (word: Word, e?: React.MouseEvent) => {
    if (e) e.stopPropagation() // Prevent card flip if event is provided
    setConfirmDeleteId(word.id)
    setIsDeleteDialogOpen(true)
  }

  const handleConfirmDelete = async () => {
    if (confirmDeleteId) {
      await deleteWord(confirmDeleteId)
      
      // Refresh the review groups
      const groups = getWordsForReview()
      setReviewGroups(groups)
      
      // Reset current card if needed
      if (reviewGroups.today.length <= currentCardIndex) {
        setCurrentCardIndex(0)
      }
      
      setIsDeleteDialogOpen(false)
      setConfirmDeleteId(null)
    }
  }

  // Get a human-readable description of a card state
  const getCardState = (state?: number) => {
    switch (state) {
      case 0: return "New";
      case 1: return "Learning";
      case 2: return "Review";
      case 3: return "Relearning";
      default: return "New";
    }
  }

  // Get the color class for a quality rating
  const getQualityColorClass = (quality: number) => {
    switch (quality) {
      case 1: return "text-red-500";
      case 2: 
      case 3: return "text-orange-500";
      case 4: return "text-green-500";
      case 5: return "text-blue-500";
      default: return "text-gray-500";
    }
  }

  // Add this function to interpret quality rating numbers
  const getQualityDescription = (quality: number): string => {
    switch (quality) {
      case 1: return "Again";
      case 2: return "Hard";
      case 3: return "Good";
      case 4: return "Easy";
      case 5: return "Mastered";
      default: return "Unknown";
    }
  };

  // Add this function to predict scheduling intervals for different ratings
  const getPredictedIntervals = (word: Word) => {
    const fsrs = new FSRS();
    const now = new Date();
    
    // Create a card object from word data
    const card = new Card();
    card.due = word.due ? new Date(word.due) : now;
    card.stability = word.stability ?? 0;
    card.difficulty = word.difficulty ?? 0.3;
    card.elapsed_days = word.elapsed_days ?? 0;
    card.scheduled_days = word.scheduled_days ?? 0;
    card.reps = word.reps ?? 0;
    card.lapses = word.lapses ?? 0;
    card.state = word.state ?? 0;
    card.last_review = word.last_review ? new Date(word.last_review) : now;
    
    // Get predictions for all ratings
    try {
      const result = fsrs.repeat(card, now);
      
      // Create prediction map
      return {
        again: formatInterval(getIntervalFromScheduling(result[Rating.Again]?.card.due, now)),
        hard: formatInterval(getIntervalFromScheduling(result[Rating.Hard]?.card.due, now)),
        good: formatInterval(getIntervalFromScheduling(result[Rating.Good]?.card.due, now)),
        easy: formatInterval(getIntervalFromScheduling(result[Rating.Easy]?.card.due, now))
      };
    } catch (error) {
      console.error("Error predicting intervals:", error);
      return {
        again: "1 min",
        hard: "5 min",
        good: "1 day",
        easy: "4 days"
      };
    }
  };

  // Helper function to calculate interval in minutes/days from due date
  const getIntervalFromScheduling = (dueDate: Date | undefined, now: Date): number => {
    if (!dueDate) return 1; // Default to 1 minute if no due date
    
    const diffTime = dueDate.getTime() - now.getTime();
    const diffMinutes = Math.round(diffTime / (1000 * 60));
    
    if (diffMinutes < 60 * 24) {
      return diffMinutes; // Return minutes for short intervals
    } else {
      return Math.round(diffMinutes / (60 * 24)); // Return days for longer intervals
    }
  };

  // Initialize Card with the correct parameters
  function getPredictedInterval(word: Word, rating: Rating): string {
    try {
      const fsrs = new FSRS();
      const now = new Date();
      
      // Create a card object from word data - fix the Card initialization
      const card = {
        due: word.due ? new Date(word.due) : now,
        stability: word.stability ?? 0,
        difficulty: word.difficulty ?? 0.3,
        elapsed_days: word.elapsed_days ?? 0,
        scheduled_days: word.scheduled_days ?? 0,
        reps: word.reps ?? 0,
        lapses: word.lapses ?? 0,
        state: word.state ?? 0,
        last_review: word.last_review ? new Date(word.last_review) : now
      };
      
      // Get scheduling predictions from FSRS
      const result = fsrs.repeat(card, now);
      
      if (result[rating]?.card?.due) {
        const dueDate = result[rating].card.due;
        const diffMinutes = Math.round((dueDate.getTime() - now.getTime()) / (1000 * 60));
        
        // Format the interval nicely
        if (diffMinutes < 1) return "now";
        if (diffMinutes < 60) return `${diffMinutes} min`;
        if (diffMinutes < 60 * 24) return `${Math.floor(diffMinutes / 60)} hour${Math.floor(diffMinutes / 60) > 1 ? 's' : ''}`;
        if (diffMinutes < 60 * 24 * 30) return `${Math.floor(diffMinutes / (60 * 24))} day${Math.floor(diffMinutes / (60 * 24)) > 1 ? 's' : ''}`;
        if (diffMinutes < 60 * 24 * 365) return `${Math.floor(diffMinutes / (60 * 24 * 30))} month${Math.floor(diffMinutes / (60 * 24 * 30)) > 1 ? 's' : ''}`;
        return `${Math.floor(diffMinutes / (60 * 24 * 365))} year${Math.floor(diffMinutes / (60 * 24 * 365)) > 1 ? 's' : ''}`;
      }
      
      // Fallback values if prediction fails
      switch (rating) {
        case Rating.Again: return "1 min";
        case Rating.Hard: return "10 min";
        case Rating.Good: return "1 day";
        case Rating.Easy: return "4 days";
        default: return "?";
      }
    } catch (error) {
      console.error("Error predicting interval:", error);
      // Fallback values
      switch (rating) {
        case Rating.Again: return "1 min";
        case Rating.Hard: return "10 min";
        case Rating.Good: return "1 day";
        case Rating.Easy: return "4 days";
        default: return "?";
      }
    }
  }

  return (
    <div className="flex flex-col items-center py-8">
      <h2 className="text-3xl font-bold text-center mb-6 text-primary">Flash Cards</h2>

      <div className="w-full max-w-3xl mb-8">
        {/* Update the Tabs component */}
        <Tabs defaultValue="today" className="w-full" onValueChange={handleTabChange} value={activeTab}>
          <TabsList className="grid w-full grid-cols-3 mb-4">
            <TabsTrigger value="today" className="flex items-center gap-2">
              <Clock className="h-4 w-4" /> Today ({reviewGroups.today.length})
            </TabsTrigger>
            <TabsTrigger value="tomorrow" className="flex items-center gap-2">
              <Calendar className="h-4 w-4" /> Tomorrow ({reviewGroups.tomorrow.length})
            </TabsTrigger>
            <TabsTrigger value="later" className="flex items-center gap-2">
              <CalendarDays className="h-4 w-4" /> Later ({reviewGroups.later.length})
            </TabsTrigger>
          </TabsList>

          <TabsContent value="today">
            {reviewGroups.today.length === 0 ? (
              <Card className="w-full p-8 text-center">
                <p className="text-muted-foreground mb-4">No cards to review today!</p>
                <p>You've completed all your reviews for today. Check back later or review upcoming cards.</p>
              </Card>
            ) : (
              <div className="w-full max-w-2xl mx-auto perspective-1000">
                <div className="relative mb-8">
                  <div className="text-center mb-4">
                    <span className="text-sm text-muted-foreground">
                      Card {currentCardIndex + 1} of {reviewGroups.today.length}
                    </span>
                  </div>

                  {reviewGroups.today[currentCardIndex] ? (
                    <motion.div
                      className="w-full h-96 cursor-pointer"
                      onClick={handleFlip}
                      animate={{ rotateY: isFlipped ? 180 : 0 }}
                      transition={{ duration: 0.6 }}
                      style={{ transformStyle: "preserve-3d" }}
                    >
                      {/* Front of card (shown first) */}
                      <div
                        className={`absolute w-full h-full backface-hidden rounded-xl p-8 flex flex-col justify-center items-center
                          ${isFlipped ? "opacity-0" : "opacity-100"} bg-gradient-to-br from-blue-400 to-purple-500 text-white shadow-xl`}
                      >
                        <div className="absolute top-4 right-4">
                          <div
                            className={getConfidenceBadgeClass(
                              reviewGroups.today[currentCardIndex].confidence,
                              reviewGroups.today[currentCardIndex].learned,
                            )}
                          >
                            <span>{reviewGroups.today[currentCardIndex].confidence}/5</span>
                            <Star className="h-4 w-4 fill-current" />
                          </div>
                        </div>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="absolute top-4 left-20 text-white hover:bg-white/20"
                          onClick={(e) => handleDeleteClick(reviewGroups.today[currentCardIndex], e)}
                        >
                          <Trash2 className="h-5 w-5" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="absolute top-4 left-12 text-white hover:bg-white/20"
                          onClick={(e) => handleEditClick(reviewGroups.today[currentCardIndex], e)}
                        >
                          <Edit className="h-5 w-5" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="absolute top-4 left-4 text-white hover:bg-white/20"
                          onClick={(e) => handleHistoryClick(reviewGroups.today[currentCardIndex], e)}
                        >
                          <HistoryIcon className="h-5 w-5" />
                        </Button>
                        <h3 className="text-4xl font-bold mb-4">{reviewGroups.today[currentCardIndex].word}</h3>

                        {/* Show example sentence in French on front */}
                        {reviewGroups.today[currentCardIndex].exampleSentence && (
                          <p className="text-lg italic mb-8 text-center">
                            "{reviewGroups.today[currentCardIndex].exampleSentence}"
                          </p>
                        )}

                        <p className="text-sm mt-4 text-blue-100">Click to flip</p>
                      </div>

                      {/* Back of card (shown after flip) */}
                      <div
                        className={`absolute w-full h-full backface-hidden rounded-xl p-8 flex flex-col justify-center items-center
                          ${isFlipped ? "opacity-100" : "opacity-0"} bg-gradient-to-br from-purple-500 to-pink-500 text-white shadow-xl`}
                        style={{ transform: "rotateY(180deg)" }}
                      >
                        <div className="absolute top-4 right-4">
                          <div
                            className={getConfidenceBadgeClass(
                              reviewGroups.today[currentCardIndex].confidence,
                              reviewGroups.today[currentCardIndex].learned,
                            )}
                          >
                            <span>{reviewGroups.today[currentCardIndex].confidence}/5</span>
                            <Star className="h-4 w-4 fill-current" />
                          </div>
                        </div>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="absolute top-4 left-20 text-white hover:bg-white/20"
                          onClick={(e) => handleDeleteClick(reviewGroups.today[currentCardIndex], e)}
                        >
                          <Trash2 className="h-5 w-5" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="absolute top-4 left-12 text-white hover:bg-white/20"
                          onClick={(e) => handleEditClick(reviewGroups.today[currentCardIndex], e)}
                        >
                          <Edit className="h-5 w-5" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="absolute top-4 left-4 text-white hover:bg-white/20"
                          onClick={(e) => handleHistoryClick(reviewGroups.today[currentCardIndex], e)}
                        >
                          <HistoryIcon className="h-5 w-5" />
                        </Button>
                        <h3 className="text-4xl font-bold mb-2">{reviewGroups.today[currentCardIndex].word}</h3>
                        <p className="text-2xl mb-4">{reviewGroups.today[currentCardIndex].meaning}</p>

                        {/* Show example sentence and translation on back */}
                        {reviewGroups.today[currentCardIndex].exampleSentence && (
                          <div className="mb-4 text-center">
                            <p className="text-lg italic">"{reviewGroups.today[currentCardIndex].exampleSentence}"</p>
                            {reviewGroups.today[currentCardIndex].exampleSentenceTranslation && (
                              <p className="text-md mt-1">
                                "{reviewGroups.today[currentCardIndex].exampleSentenceTranslation}"
                              </p>
                            )}
                          </div>
                        )}
                        
                        {/* Card metrics display */}
                        <div className="flex flex-col items-center mt-2 mb-2 text-xs text-white/80">
                          <div className="flex items-center gap-1 mb-1">
                            <Info className="h-3 w-3" />
                            <span>Status: {getCardState(reviewGroups.today[currentCardIndex].state)}</span>
                          </div>
                          <div className="flex items-center gap-1 mb-1">
                            <Info className="h-3 w-3" />
                            <span>Memory stability: {formatStability(reviewGroups.today[currentCardIndex].stability)}</span>
                          </div>
                          <div className="flex items-center gap-1 mb-1">
                            <Info className="h-3 w-3" />
                            <span>Difficulty: {formatDifficulty(reviewGroups.today[currentCardIndex].difficulty)}</span>
                          </div>
                          <div className="flex items-center gap-1 mb-1">
                            <Info className="h-3 w-3" />
                            <span>Current interval: {formatInterval(reviewGroups.today[currentCardIndex].interval || 0)}</span>
                          </div>
                          <div className="flex items-center gap-1">
                            <Calendar className="h-3 w-3" />
                            <span>Next review: {formatNextReview(reviewGroups.today[currentCardIndex].due)}</span>
                          </div>
                        </div>

                        <p className="text-sm mt-2 text-pink-100">Click to flip back</p>
                      </div>
                    </motion.div>
                  ) : (
                    <Card className="w-full p-8 text-center">
                      <p className="text-muted-foreground mb-4">No card found!</p>
                      <p>There was an issue loading this card. Please refresh the page or check back later.</p>
                    </Card>
                  )}
                </div>

                {/* Answer buttons and spaced repetition information - only show when card is flipped and a card exists */}
                {isFlipped && reviewGroups.today.length > 0 && reviewGroups.today[currentCardIndex] && (
                  <>
                    {/* Add prediction calculations for the buttons */}
                    {(() => {
                      // Calculate predicted intervals for each rating
                      const fsrs = new FSRS();
                      const now = new Date();
                      const currentWord = reviewGroups.today[currentCardIndex];
                      
                      // Create a card object for FSRS correctly
                      const card = {
                        due: currentWord.due ? new Date(currentWord.due) : now,
                        stability: currentWord.stability ?? 0,
                        difficulty: currentWord.difficulty ?? 0.3,
                        elapsed_days: currentWord.elapsed_days ?? 0,
                        scheduled_days: currentWord.scheduled_days ?? 0,
                        reps: currentWord.reps ?? 0,
                        lapses: currentWord.lapses ?? 0,
                        state: currentWord.state ?? 0,
                        last_review: currentWord.last_review ? new Date(currentWord.last_review) : now
                      };
                      
                      let predictions = {
                        again: "1 min",
                        hard: "5 min",
                        good: "1 day",
                        easy: "4 days"
                      };
                      
                      try {
                        // Get scheduling predictions from FSRS
                        const result = fsrs.repeat(card, now);
                        
                        // Calculate intervals for each rating
                        if (result[Rating.Again]?.card) {
                          const againDate = result[Rating.Again].card.due;
                          const againMinutes = Math.round((againDate.getTime() - now.getTime()) / (1000 * 60));
                          predictions.again = againMinutes < 60 ? `${againMinutes} min` : 
                                            againMinutes < 60 * 24 ? `${Math.floor(againMinutes / 60)} hour${Math.floor(againMinutes / 60) > 1 ? 's' : ''}` :
                                            `${Math.floor(againMinutes / (60 * 24))} day${Math.floor(againMinutes / (60 * 24)) > 1 ? 's' : ''}`;
                        }
                        
                        if (result[Rating.Hard]?.card) {
                          const hardDate = result[Rating.Hard].card.due;
                          const hardMinutes = Math.round((hardDate.getTime() - now.getTime()) / (1000 * 60));
                          predictions.hard = hardMinutes < 60 ? `${hardMinutes} min` : 
                                           hardMinutes < 60 * 24 ? `${Math.floor(hardMinutes / 60)} hour${Math.floor(hardMinutes / 60) > 1 ? 's' : ''}` :
                                           hardMinutes < 60 * 24 * 30 ? `${Math.floor(hardMinutes / (60 * 24))} day${Math.floor(hardMinutes / (60 * 24)) > 1 ? 's' : ''}` :
                                           `${Math.floor(hardMinutes / (60 * 24 * 30))} month${Math.floor(hardMinutes / (60 * 24 * 30)) > 1 ? 's' : ''}`;
                        }
                        
                        if (result[Rating.Good]?.card) {
                          const goodDate = result[Rating.Good].card.due;
                          const goodMinutes = Math.round((goodDate.getTime() - now.getTime()) / (1000 * 60));
                          predictions.good = goodMinutes < 60 ? `${goodMinutes} min` : 
                                           goodMinutes < 60 * 24 ? `${Math.floor(goodMinutes / 60)} hour${Math.floor(goodMinutes / 60) > 1 ? 's' : ''}` :
                                           goodMinutes < 60 * 24 * 30 ? `${Math.floor(goodMinutes / (60 * 24))} day${Math.floor(goodMinutes / (60 * 24)) > 1 ? 's' : ''}` :
                                           goodMinutes < 60 * 24 * 365 ? `${Math.floor(goodMinutes / (60 * 24 * 30))} month${Math.floor(goodMinutes / (60 * 24 * 30)) > 1 ? 's' : ''}` :
                                           `${Math.floor(goodMinutes / (60 * 24 * 365))} year${Math.floor(goodMinutes / (60 * 24 * 365)) > 1 ? 's' : ''}`;
                        }
                        
                        if (result[Rating.Easy]?.card) {
                          const easyDate = result[Rating.Easy].card.due;
                          const easyMinutes = Math.round((easyDate.getTime() - now.getTime()) / (1000 * 60));
                          predictions.easy = easyMinutes < 60 ? `${easyMinutes} min` : 
                                           easyMinutes < 60 * 24 ? `${Math.floor(easyMinutes / 60)} hour${Math.floor(easyMinutes / 60) > 1 ? 's' : ''}` :
                                           easyMinutes < 60 * 24 * 30 ? `${Math.floor(easyMinutes / (60 * 24))} day${Math.floor(easyMinutes / (60 * 24)) > 1 ? 's' : ''}` :
                                           easyMinutes < 60 * 24 * 365 ? `${Math.floor(easyMinutes / (60 * 24 * 30))} month${Math.floor(easyMinutes / (60 * 24 * 30)) > 1 ? 's' : ''}` :
                                           `${Math.floor(easyMinutes / (60 * 24 * 365))} year${Math.floor(easyMinutes / (60 * 24 * 365)) > 1 ? 's' : ''}`;
                        }
                      } catch (error) {
                        console.error("Error predicting intervals:", error);
                        // Use fallback values already set
                      }
                      
                      return (
                        <div className="flex justify-center gap-2">
                          <Button
                            variant="outline"
                            onClick={handleAgain}
                            className="flex-1 border-red-300 hover:bg-red-50 hover:text-red-600"
                            title="I forgot this word completely"
                          >
                            Again ({predictions.again})
                          </Button>

                          <Button
                            variant="outline"
                            onClick={handleHard}
                            className="flex-1 border-orange-300 hover:bg-orange-50 hover:text-orange-600"
                            title="I remembered with difficulty"
                          >
                            Hard ({predictions.hard})
                          </Button>

                          <Button
                            variant="outline"
                            onClick={handleGood}
                            className="flex-1 border-green-300 hover:bg-green-50 hover:text-green-600"
                            title="I remembered well"
                          >
                            Good ({predictions.good})
                          </Button>

                          <Button
                            variant="outline"
                            onClick={handleEasy}
                            className="flex-1 border-blue-300 hover:bg-blue-50 hover:text-blue-600"
                            title="I remembered perfectly"
                          >
                            Easy ({predictions.easy})
                          </Button>
                        </div>
                      );
                    })()}
                    
                    <div className="mt-4 p-4 bg-slate-100 rounded-md text-xs text-slate-600">
                      <h4 className="font-bold mb-1 flex items-center gap-1">
                        <Info className="h-3 w-3" /> About FSRS Spaced Repetition
                      </h4>
                      <p className="mb-1">
                        This flashcard system uses the Free Spaced Repetition Scheduler (FSRS) algorithm 
                        that optimizes your learning by predicting when you're likely to forget:
                      </p>
                      <ul className="list-disc pl-4 space-y-1">
                        <li><span className="text-red-500 font-bold">Again</span>: You forgot this card - it will reappear soon for intensive review</li>
                        <li><span className="text-orange-500 font-bold">Hard</span>: You remembered with difficulty - the next interval will be shorter</li>
                        <li><span className="text-green-500 font-bold">Good</span>: You remembered correctly - optimal interval increase</li>
                        <li><span className="text-blue-500 font-bold">Easy</span>: You remembered easily - larger interval increase</li>
                      </ul>
                    </div>
                  </>
                )}
              </div>
            )}
          </TabsContent>

          <TabsContent value="tomorrow">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {reviewGroups.tomorrow.length === 0 ? (
                <Card className="w-full p-8 text-center col-span-2">
                  <p className="text-muted-foreground mb-4">No cards scheduled for tomorrow!</p>
                </Card>
              ) : (
                reviewGroups.tomorrow.map((word) => (
                  <Card key={word.id} className="p-4 relative">
                    <div className="flex justify-between items-start mb-2">
                      <h3 className="font-bold text-lg">{word.word}</h3>
                      <div className={getConfidenceBadgeClass(word.confidence, word.learned)}>
                        <span>{word.confidence}/5</span>
                        <Star className={`h-4 w-4 fill-current`} />
                      </div>
                    </div>
                    <p>{word.meaning}</p>
                    {word.exampleSentence && <p className="text-sm italic mt-2">"{word.exampleSentence}"</p>}
                    {word.exampleSentenceTranslation && (
                      <p className="text-sm mt-1">"{word.exampleSentenceTranslation}"</p>
                    )}
                    <div className="mt-2 flex justify-end">
                      <Button variant="ghost" size="sm" onClick={() => handleHistoryClick(word)}>
                        <HistoryIcon className="h-4 w-4" />
                      </Button>
                      <Button variant="ghost" size="sm" onClick={() => handleEditClick(word)}>
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleDeleteClick(word)}
                        className="text-red-500 hover:text-red-700 hover:bg-red-100"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </Card>
                ))
              )}
            </div>
          </TabsContent>

          <TabsContent value="later">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {reviewGroups.later.length === 0 ? (
                <Card className="w-full p-8 text-center col-span-2">
                  <p className="text-muted-foreground mb-4">No cards scheduled for later!</p>
                </Card>
              ) : (
                reviewGroups.later.map((word) => (
                  <Card key={word.id} className="p-4 relative">
                    <div className="flex justify-between items-start mb-2">
                      <h3 className="font-bold text-lg">{word.word}</h3>
                      <div className={getConfidenceBadgeClass(word.confidence, word.learned)}>
                        <span>{word.confidence}/5</span>
                        <Star className={`